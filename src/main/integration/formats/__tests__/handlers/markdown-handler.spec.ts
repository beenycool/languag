// src/main/integration/formats/__tests__/handlers/markdown-handler.spec.ts

/**
 * @file Test suite for MarkdownHandler.
 * @description Ensures correct parsing, serialization, and metadata extraction for Markdown files.
 * Covers normal operation, various Markdown features, edge cases, and error handling.
 */

// Assuming MarkdownHandler and IFormatHandler interface are defined.
// import MarkdownHandler from '../../handlers/markdown-handler'; // Adjust path as needed
// import { ParsedContent, FileMetadata } from '../../core/format-registry'; // Or types.ts

describe('MarkdownHandler - Markdown File Tests', () => {
  let markdownHandler: any; // Replace 'any' with MarkdownHandler type

  beforeEach(() => {
    // markdownHandler = new MarkdownHandler();
  });

  describe('Supported Extensions and Name', () => {
    it('should report correct name', () => {
      // expect(markdownHandler.name).toBe('markdown');
    });

    it('should report supported extensions', () => {
      // const extensions = markdownHandler.supportedExtensions;
      // expect(extensions).toContain('.md');
      // expect(extensions).toContain('.markdown');
    });
  });

  describe('Parsing (Buffer to ParsedContent)', () => {
    it('should parse a Buffer containing simple Markdown text correctly', async () => {
      // const mdText = '# Title\n\nSome paragraph.';
      // const buffer = Buffer.from(mdText, 'utf-8');
      // const parsed: ParsedContent = await markdownHandler.parse(buffer);
      // expect(parsed).toBeDefined();
      // expect(parsed.type).toBe('markdown');
      // expect(parsed.markdownContent).toBe(mdText);
      // // Optionally, if the handler also produces an AST or HTML representation:
      // // expect(parsed.ast).toBeDefined();
      // // expect(parsed.htmlPreview).toContain('<h1>Title</h1>');
    });

    it('should handle an empty Markdown file', async () => {
      // const buffer = Buffer.from('', 'utf-8');
      // const parsed: ParsedContent = await markdownHandler.parse(buffer);
      // expect(parsed.markdownContent).toBe('');
      // // expect(parsed.ast).toBeNull(); // Or an empty AST structure
    });

    it('should parse various Markdown elements: headers, lists, bold, italic, links, images, code blocks', async () => {
      // const complexMd = `
      //   # H1
      //   ## H2
      //   *italic* **bold** \`code\`
      //   - List item 1
      //   - List item 2
      //   [Link](http://example.com)
      //   ![Image](http://example.com/img.png)
      //   \`\`\`javascript
      //   console.log("hello");
      //   \`\`\`
      // `;
      // const buffer = Buffer.from(complexMd, 'utf-8');
      // const parsed: ParsedContent = await markdownHandler.parse(buffer);
      // expect(parsed.markdownContent).toBe(complexMd);
      // // Add more specific checks if an AST or HTML preview is generated by .parse()
      // // For example, if it generates an AST:
      // // expect(parsed.ast.children.some(node => node.type === 'heading' && node.depth === 1)).toBe(true);
      // // expect(parsed.ast.children.some(node => node.type === 'list')).toBe(true);
    });

    it('should handle Markdown with frontmatter if supported', async () => {
      // const mdWithFrontmatter = `
      // ---
      // title: My Document
      // author: Test User
      // tags: [test, markdown]
      // ---
      // # Actual Content
      // This is the body.
      // `;
      // const buffer = Buffer.from(mdWithFrontmatter, 'utf-8');
      // const parsed: ParsedContent = await markdownHandler.parse(buffer);
      // expect(parsed.markdownContent).toContain('# Actual Content'); // Main content
      // expect(parsed.frontmatter).toEqual({
      //   title: 'My Document',
      //   author: 'Test User',
      //   tags: ['test', 'markdown'],
      // });
    });
  });

  describe('Serialization (ParsedContent to Buffer)', () => {
    it('should serialize Markdown content to a Buffer', async () => {
      // const mdText = '## Section\nContent here.';
      // const parsed: ParsedContent = { type: 'markdown', markdownContent: mdText };
      // const buffer = await markdownHandler.serialize(parsed);
      // expect(buffer).toBeInstanceOf(Buffer);
      // expect(buffer.toString('utf-8')).toBe(mdText);
    });

    it('should serialize Markdown content including frontmatter if present in ParsedContent', async () => {
      // const frontmatter = { title: 'Serialized Doc', version: 1 };
      // const body = '\n# Hello';
      // const parsed: ParsedContent = { type: 'markdown', markdownContent: body, frontmatter: frontmatter };
      // const buffer = await markdownHandler.serialize(parsed);
      // const serializedString = buffer.toString('utf-8');
      // expect(serializedString).toMatch(/^---\s*title: Serialized Doc\s*version: 1\s*---\s*# Hello/s);
    });

    it('should handle ParsedContent with missing markdownContent (e.g., serialize to empty or only frontmatter)', async () => {
      // const parsed: ParsedContent = { type: 'markdown', frontmatter: { title: 'Empty Body' } };
      // const buffer = await markdownHandler.serialize(parsed);
      // const serializedString = buffer.toString('utf-8');
      // expect(serializedString).toMatch(/^---\s*title: Empty Body\s*---\s*$/s); // Only frontmatter
    });

    it('should throw an error if serializing ParsedContent of an incompatible type', async () => {
      // const parsed: ParsedContent = { type: 'text', textContent: 'Just text' };
      // await expect(markdownHandler.serialize(parsed)).rejects.toThrow(/Incompatible ParsedContent type/i);
    });
  });

  describe('Metadata Extraction', () => {
    it('should extract basic metadata from Markdown content', async () => {
      // const mdText = '# My Title\nSome content here.';
      // const buffer = Buffer.from(mdText);
      // const filePath = 'document.md';
      // const metadata: FileMetadata = await markdownHandler.getMetadata(buffer, filePath);

      // expect(metadata.fileName).toBe('document.md');
      // expect(metadata.fileType).toBe('text/markdown'); // Or as defined
      // expect(metadata.fileSize).toBe(buffer.length);
      // // Specific Markdown metadata:
      // expect(metadata.customMarkdownStats?.headingCount?.h1).toBe(1);
      // expect(metadata.customMarkdownStats?.wordCount).toBe(4); // "My Title Some content"
      // expect(metadata.frontmatter?.title).toBeUndefined(); // No frontmatter in this example
    });

    it('should extract metadata including frontmatter data if present', async () => {
      // const mdWithFrontmatter = '---\ntitle: Test Doc\nauthor: Me\n---\n# Content';
      // const buffer = Buffer.from(mdWithFrontmatter);
      // const metadata: FileMetadata = await markdownHandler.getMetadata(buffer, 'fm.md');
      // expect(metadata.frontmatter?.title).toBe('Test Doc');
      // expect(metadata.frontmatter?.author).toBe('Me');
      // expect(metadata.customMarkdownStats?.headingCount?.h1).toBe(1);
    });
  });

  describe('Transformation Capabilities', () => {
    it('should report if it can transform to another format (e.g., HTML, text)', () => {
      // expect(markdownHandler.canTransformTo('html')).toBe(true);
      // expect(markdownHandler.canTransformTo('text')).toBe(true); // Stripping MD to get text
      // expect(markdownHandler.canTransformTo('json')).toBe(false);
    });

    it('should transform Markdown content to HTML', async () => {
      // const markdownData: ParsedContent = { type: 'markdown', markdownContent: '## Hello' };
      // const htmlData: ParsedContent = await markdownHandler.transformTo(markdownData, 'html');
      // expect(htmlData.type).toBe('html');
      // expect(htmlData.htmlContent).toMatch(/<h2[^>]*>Hello<\/h2>/);
    });

    it('should transform Markdown content to plain text', async () => {
      // const markdownData: ParsedContent = {
      //   type: 'markdown',
      //   markdownContent: '# Title\n\nSome *bold* text and a [link](url).'
      // };
      // const textData: ParsedContent = await markdownHandler.transformTo(markdownData, 'text');
      // expect(textData.type).toBe('text');
      // expect(textData.textContent).toBe('Title\n\nSome bold text and a link.'); // Example of stripped text
    });

    it('should throw if attempting to transform to an unsupported format', async () => {
      // const markdownData: ParsedContent = { type: 'markdown', markdownContent: 'test' };
      // await expect(markdownHandler.transformTo(markdownData, 'json'))
      //   .rejects.toThrow(/Transformation to json not supported/i);
    });
  });
});